# **shopping-offers**

**ğŸ”— é¢˜ç›®é“¾æ¥ï¼š**  
**[shopping-offers](https://leetcode.cn/problems/shopping-offers/)**

---

## **è§£é¢˜ä»£ç ï¼ˆC++ï¼‰**

```cpp
#include <bits/stdc++.h>
using namespace std;

// å®šä¹‰ hash å‡½æ•°ï¼ŒæŠŠ vector<int> å½“ä½œ key
struct VectorHash {
    size_t operator()(const vector<int>& v) const {
        size_t hash = 0;
        for (int x : v) {
            hash = hash * 31 + x; // ç®€å•å“ˆå¸Œç»„åˆ
        }
        return hash;
    }
};

class Solution {
public:
    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {
        unordered_map<vector<int>, int, VectorHash> memo;
        return dfs(price, special, needs, memo);
    }

private:
    int dfs(vector<int>& price, vector<vector<int>>& special, vector<int>& needs,
            unordered_map<vector<int>, int, VectorHash>& memo) {
        // 1ï¸âƒ£ å¦‚æœå·²ç»ç®—è¿‡è¿™ä¸ªçŠ¶æ€ï¼Œç›´æ¥è¿”å›
        if (memo.count(needs)) return memo[needs];

        int n = needs.size();
        int cost = 0;

        // 2ï¸âƒ£ ä¸ç”¨ç¤¼åŒ…ï¼Œå•ä¹°æ‰€æœ‰å‰©ä½™å•†å“ï¼ˆåˆå§‹åŒ–ï¼‰
        for (int i = 0; i < n; i++) cost += needs[i] * price[i];

        // 3ï¸âƒ£ å°è¯•æ¯ä¸ªç¤¼åŒ…
        for (auto& offer : special) {
            bool canUse = true;
            vector<int> nextNeeds(n);
            for (int i = 0; i < n; i++) {
                nextNeeds[i] = needs[i] - offer[i];
                if (nextNeeds[i] < 0) {
                    canUse = false; // ç¤¼åŒ…å•†å“ä¸å¤Ÿï¼Œä¸èƒ½ç”¨
                    break;
                }
            }
            if (canUse) {
                // ç”¨ç¤¼åŒ… + å‰©ä½™éœ€æ±‚é€’å½’æœ€å°èŠ±è´¹
                cost = min(cost, offer[n] + dfs(price, special, nextNeeds, memo));
            }
        }

        // 4ï¸âƒ£ è®°å¿†åŒ–ä¿å­˜
        memo[needs] = cost;
        return cost;
    }
};

è§£é¢˜æ€è·¯ï¼š
æœ¬é¢˜æ‰“ç ´äº†æ›¾ç»æˆ‘å¯¹åŠ¨æ€è§„åˆ’çº¿æ€§å­˜å‚¨çš„å›ºæœ‰è®¤çŸ¥ï¼Œè¿™é‡Œå…¶å®å¯ä»¥ç›´æ¥å°†å…¶æŠ½è±¡åŒ–ï¼Œå…ˆæŠŠ
éœ€æ±‚åˆ†ä¸ºå­é—®é¢˜ï¼Œç„¶åæŠŠæ‰€æœ‰é—®é¢˜ç›´æ¥æŠ½è±¡æˆèŠ‚ç‚¹ï¼Œç‚¹æœ‰ç‚¹ä¹‹é—´çš„è·¯å¾„å°±æ˜¯æ“ä½œï¼Œæ¯ä¸ªè¾¹
æƒå€¼å¯ä»¥çœ‹æˆä»£ä»·ã€‚æœ¬é¢˜é‡‡ç”¨äº†å“ˆå¸Œè¡¨å»å­˜å‚¨ï¼Œå› ä¸ºæ¯ä¸ªç‰©å“çš„éœ€æ±‚å“¦ä¼šä¸ä¸€æ ·ï¼Œæ‰€ä»¥ç®€
å•çš„äºŒç»´æ•°ç»„å·²ç»æ»¡è¶³ä¸äº†è¦æ±‚äº†ï¼Œå¦å¤–å“ˆå¸Œå‡½æ•°éœ€è¦è‡ªå·±å†™ï¼Œå› ä¸ºåº“é‡Œé¢æ²¡æœ‰å¯¹vector
çš„å“ˆå¸Œæ˜ å°„ã€‚åŒæ—¶å¯ä»¥å‘ç°åœ¨å¤„ç†æ¯ä¸ªéœ€æ±‚çš„æ—¶å€™éƒ½ä¼šå°†å…¶ç”¨å•ä¸ªç‰©å“çš„è´­ä¹°æ–¹å¼è´­ä¹°ä¸€
éï¼Œè¿™å…¶å®å°±æ˜¯ç›¸å½“äºåˆå§‹åŒ–ï¼Œå› ä¸ºè¿™æ ·å­çš„è´­ä¹°ä»£ä»·å¿…ç„¶æ˜¯æœ€å¤§çš„ã€‚
