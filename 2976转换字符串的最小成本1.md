# **minimum-cost-to-convert-string-i**

**ğŸ”— é¢˜ç›®é“¾æ¥ï¼š**  
**[minimum-cost-to-convert-string-i](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/)**

---

## **è§£é¢˜ä»£ç ï¼ˆC++ï¼‰**

```cpp
class Solution {
public:
    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {
        const long long INF = 1e18;
        long long dp[26][26];

        // 1. åˆå§‹åŒ– dp
        for (int i = 0; i < 26; i++) {
            for (int j = 0; j < 26; j++) {
                if (i == j) dp[i][j] = 0;
                else dp[i][j] = INF;
            }
        }

        // 2. å¡«å…¥ direct è½¬æ¢ä»£ä»·
        int m = original.size();
        for (int i = 0; i < m; i++) {
            int u = original[i] - 'a';
            int v = changed[i] - 'a';
            dp[u][v] = min(dp[u][v], (long long)cost[i]);
        }

        // 3. Floyd-Warshall
        for (int k = 0; k < 26; k++) {
            for (int i = 0; i < 26; i++) {
                for (int j = 0; j < 26; j++) {
                    if (dp[i][k] < INF && dp[k][j] < INF) {
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
                    }
                }
            }
        }

        // 4. è®¡ç®—è½¬æ¢ source -> target çš„æ€»ä»£ä»·
        long long total = 0;
        int n = source.size();
        for (int i = 0; i < n; i++) {
            int u = source[i] - 'a';
            int v = target[i] - 'a';
            if (dp[u][v] == INF) return -1; // æ— æ³•è½¬æ¢
            total += dp[u][v];
        }

        return total;
    }
};

è§£é¢˜æ€è·¯ï¼š
ç”±åˆ†æå¯çŸ¥ï¼Œè½¬æ¢çš„æ—¶å€™å¯ä»¥æœ‰å¤šæ¬¡ä¸­è½¬ï¼Œæ‰€ä»¥å°±æ˜¯å›¾çš„é—®é¢˜ï¼ŒæŠŠ26ä¸ªå­—æ¯å…¨éƒ¨çœ‹æˆç‚¹ï¼Œ
å…ˆæ±‚ç‚¹åˆ°ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œä»£ä»·å°±æ˜¯è·¯å¾„é•¿åº¦ã€‚é‡‡ç”¨Floydç®—æ³•ï¼Œå¦å¤–kè¦åœ¨æœ€å¤–å±‚å¾ªç¯ï¼Œè¿™æ ·
æ‰èƒ½ä¿è¯æ¯æ¬¡ç”¨åˆ°çš„ä¸­è½¬ç‚¹éƒ½æ˜¯æ›´æ–°è¿‡çš„ã€‚
