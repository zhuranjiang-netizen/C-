# **task-scheduler**
**🔗 题目链接：**  
**[task-scheduler](https://leetcode.cn/problems/task-scheduler/)**

---

## **解题代码（C++）**

```cpp
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        // 统计每个任务出现次数
        vector<int> cnt(26, 0);
        for (char c : tasks) cnt[c - 'A']++;

        // 初始化最大堆
        priority_queue<int> pq;
        for (int c : cnt) if (c > 0) pq.push(c);

        int time = 0;

        // 主循环：只要堆不空就继续
        while (!pq.empty()) {
            int k = n + 1;           // 一轮最多执行 n+1 个任务
            vector<int> tmp;         // 临时存储本轮执行后剩余的任务

            // 执行一轮
            while (k-- > 0 && !pq.empty()) {
                int x = pq.top(); pq.pop();
                x--;                 // 执行一次
                tmp.push_back(x);    // 剩余次数大于 0 才放回堆
                time++;              // 时间 +1
            }

            // 把剩余任务放回堆
            for (int x : tmp) if (x > 0) pq.push(x);

            // 如果堆不空，本轮没满 n+1，需要补 idle
            if (!pq.empty()) time += k + 1;  // k+1 是剩余空位数
        }

        return time;
    }
};

解题思路：
题目采用贪心算法，并使用了优先队列去辅助，贪心的思路是越多的任务要最先完成，因为你越往后拖，时间肯定识别要加长的。
所以采用优先队列去保证每次都能弹出次数最多的，解法是采用n+1为一个轮次，并且每个轮次只保证那些任务执行了，并不保
证其先后，因为n+1已经控制了在这一轮内完成的任务下一个轮次内依旧能够去使用。
